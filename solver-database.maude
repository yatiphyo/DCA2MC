fmod TRANSITION-TERM is
    pr 2TUPLE{Term,Qid} * (
        op `(_`,_`) to <_`,_>,
        op p1_ to getState,
        op p2_ to getLabel,
        sort Tuple{Term,Qid} to TransitionTerm) .
endfm

view TransitionTerm from TRIV to TRANSITION-TERM is
    sort Elt to TransitionTerm .
endv

fmod TRANSITION-TERM-LIST is
    pr LIST{TransitionTerm} * (sort NeList{TransitionTerm} to NeTransitionTermList, sort List{TransitionTerm} to TransitionTermList) .
endfm

fmod TRACE is
    pr 2TUPLE{Term,Nat} * (
        op `(_`,_`) to <_:_>,
        op p1_ to getState,
        op p2_ to getDepth,
        sort Tuple{Term,Nat} to Log) .
endfm

view Log from TRIV to TRACE is
    sort Elt to Log .
endv

fmod TRACE-LIST is
    pr LIST{Log} * (sort NeList{Log} to NeLogList, sort List{Log} to LogList) .
endfm

view LogList from TRIV to TRACE-LIST is
    sort Elt to LogList .
endv

view LogList from TRIV to TRACE-LIST is
    sort Elt to LogList .
endv

fmod STATE-TYPE is
    sort StateType .
    ops cx all : -> StateType [ctor] .
endfm

view State-Type from TRIV to STATE-TYPE is
    sort Elt to StateType .
endv

fmod STATE is
    pr 5TUPLE{Term,State-Type,Bound,Bound,LogList} * (
        op p1_ to getState,
        op p2_ to getType,
        op p3_ to getDepth,
        op p4_ to getNextDepth,
        op p5_ to getLog,
        sort Tuple{Term,State-Type,Bound,Bound,LogList} to State
    ) .
    op null : -> State [ctor] .
endfm

view State from TRIV to STATE is
    sort Elt to State .
endv

fmod STATE-SET is
    pr SET{State} * (sort Set{State} to StateSet) .
endfm

view StateSet from TRIV to STATE-SET is
    sort Elt to StateSet .
endv

fmod STATES-&-CXSTATES is
    pr 2TUPLE{TermSet,TermSet} * (
        op `(_`,_`) to <_:_>,
        op p1_ to states,
        op p2_ to cxStates,
        sort Tuple{TermSet,TermSet} to States&CxStates) .
endfm

view States&CxStates from TRIV to STATES-&-CXSTATES is
    sort Elt to States&CxStates .
endv

fmod NODE is
    pr 2TUPLE{States&CxStates,LogList} * (
        op `(_`,_`) to <_:_>,
        op p1_ to states&CxStates,
        op p2_ to logList,
        sort Tuple{States&CxStates,LogList} to Node) .
endfm

view Node from TRIV to NODE is
    sort Elt to Node .
endv

fmod NODESET is
    pr SET{Node} * (sort NeSet{Node} to NeNodeSet, sort Set{Node} to NodeSet) .
endfm

view NodeSet from TRIV to NODESET is
    sort Elt to NodeSet .
endv

fmod DATABASE-EXT-DECL is
    pr NODESET .
    sorts ConfigExt OCompExt FormulaType .

    --- Prepare the sort of the result that be retured by checking
    sorts Result4Checking Result4Checking? .
    subsort Result4Checking < Result4Checking? .

    --- supported formulas
    ops leadsTo eventual cstable : -> FormulaType [ctor] .

    --- Define structure of message error as well as success
    op nil : -> Result4Checking [ctor] .
    op success : -> Result4Checking [ctor] .
    op {formula:_, term:_, trace:_, cx:_} : Term Term LogList Term -> Result4Checking? [ctor] .
    op getFormula : Result4Checking? -> Term .
    op getTerm : Result4Checking? -> Term .
    op getLogList : Result4Checking? -> LogList .
    op getCx : Result4Checking? -> Term .
    eq getFormula({formula: F:Term, term: T:Term, trace: L:LogList, cx: Cx:Term}) = F:Term .
    eq getTerm({formula: F:Term, term: T:Term, trace: L:LogList, cx: Cx:Term}) = T:Term .
    eq getLogList({formula: F:Term, term: T:Term, trace: L:LogList, cx: Cx:Term}) = L:LogList .
    eq getCx({formula: F:Term, term: T:Term, trace: L:LogList, cx: Cx:Term}) = Cx:Term .

    op (originModule:_) : ModuleExpression -> ConfigExt [ctor format (! o o)] .
    op (reviseModule:_) : ModuleExpression -> ConfigExt [ctor format (! o o)] .
    op (initState:_) : Term -> ConfigExt [ctor format (! o o)] .
    op (eleSort:_) : Sort -> ConfigExt [ctor format (! o o)] .
    op (soupSort:_) : Sort -> ConfigExt [ctor format (! o o)] .
    op (eventuallyProp:_) : Term -> ConfigExt [ctor format (! o o)] .
    op (type:_) : FormulaType -> ConfigExt [ctor format (! o o)] .
    op (cxFormula:_) : Term -> ConfigExt [ctor format (! o o)] .
    op (ncxFormula:_) : Term -> ConfigExt [ctor format (! o o)] .
    op (midFormula:_) : Term -> ConfigExt [ctor format (! o o)] .

    op (depthList:_) : NatList -> OCompExt [ctor format (! o o)] .
    op (currentDepth:_) : Nat -> OCompExt [ctor format (! o o)] .
    op (nodeSet:_) : NodeSet -> OCompExt [ctor format (! o o)] .
    op (result:_) : Result4Checking? -> OCompExt [ctor format (m o o)] .
endfm

view ConfigExt from TRIV to DATABASE-EXT-DECL is
    sort Elt to ConfigExt .
endv

view OCompExt from TRIV to DATABASE-EXT-DECL is
    sort Elt to OCompExt .
endv

fmod CONFIG-EXT&STATE-EXT is
    pr SET{ConfigExt} * (sort NeSet{ConfigExt} to NeConfigExtSet, sort Set{ConfigExt} to ConfigExtSet, op empty : -> Set{ConfigExt} to emptyConfigExt) .
    pr SET{OCompExt} * (sort NeSet{OCompExt} to NeOCompExtSet, sort Set{OCompExt} to OCompExtSet, op empty : -> Set{OCompExt} to emptyOCompExt) .
endfm

view ConfigExtSet from TRIV to CONFIG-EXT&STATE-EXT is
    sort Elt to ConfigExtSet .
endv

view OCompExtSet from TRIV to CONFIG-EXT&STATE-EXT is
    sort Elt to OCompExtSet .
endv

fmod DATABASE-EXT is
    pr SOLVER-COMMON .
    pr STATE .
    pr STATE-SET .
    pr 2TUPLE{ConfigExtSet,OCompExtSet} * (op `(_`,_`) to `{_;_`},
        op p1_ to getConfig,
        op p2_ to getState,
        sort Tuple{ConfigExtSet,OCompExtSet} to DatabaseExt) .

    vars C : ConfigExt .
    vars Cs : ConfigExtSet .
    var Oc : OCompExt .
    vars OCs OCs' : OCompExtSet .
    vars DB-EXT : DatabaseExt .
    vars ME : ModuleExpression .
    vars T T1 T2 : Term .
    vars T' : [Term] .
    vars S : Sort .
    vars NL NL' : NatList .
    vars N N' N'' : Nat .
    vars NS NS' : NodeSet .
    vars ND : Node .
    vars R4C R4C' : Result4Checking? .
    vars B : Bool .
    vars ST : State .
    vars STYPE : StateType .
    vars FT : FormulaType .

    op sum : NatList -> Nat .
    eq sum(N NL) = N + sum(NL) .
    eq sum(nil) = 0 .

    op emptyDatabaseExt : -> DatabaseExt [ctor] .
    op isEmptyDatabaseExt : DatabaseExt -> Bool .
    ceq isEmptyDatabaseExt(DB-EXT) = true if DB-EXT == emptyDatabaseExt .
    eq isEmptyDatabaseExt(DB-EXT) = false [owise] .

    op getConfigExtSet : DatabaseExt -> ConfigExtSet .
    eq getConfigExtSet({ Cs ; OCs }) = Cs .
    op getOCompExtSet : DatabaseExt -> OCompExtSet .
    eq getOCompExtSet({ Cs ; OCs }) = OCs .

    op originModule : ConfigExtSet -> ModuleExpression .
    op reviseModule : ConfigExtSet -> ModuleExpression .
    op initState : ConfigExtSet -> Term .
    op eventuallyProp : ConfigExtSet -> Term .
    op eleSort : ConfigExtSet -> Sort .
    op soupSort : ConfigExtSet -> Sort .
    op cxFormula : ConfigExtSet -> Term .
    op ncxFormula : ConfigExtSet -> Term .
    op midFormula : ConfigExtSet -> Term .
    op type : ConfigExtSet -> FormulaType .

    eq originModule(((originModule: ME), Cs)) = ME .
    eq reviseModule(((reviseModule: ME), Cs)) = ME .
    eq initState(((initState: T), Cs)) = T .
    eq eventuallyProp(((eventuallyProp: T) , Cs)) = T .
    eq eleSort(((eleSort: S) , Cs)) = S .
    eq soupSort(((soupSort: S) , Cs)) = S .
    eq cxFormula(((cxFormula: T) , Cs)) = T .
    eq ncxFormula(((ncxFormula: T) , Cs)) = T .
    eq midFormula(((midFormula: T) , Cs)) = T .
    eq type(((type: FT) , Cs)) = FT .

    op depthList : OCompExtSet -> NatList .
    op currentDepth : OCompExtSet -> Nat .
    op nodeSet : OCompExtSet -> NodeSet .
    op result : OCompExtSet -> Result4Checking? .

    eq depthList(((depthList: NL), OCs)) = NL .
    eq currentDepth(((currentDepth: N), OCs)) = N .
    eq nodeSet(((nodeSet: NS), OCs)) = NS .
    eq result(((result: R4C), OCs)) = R4C .

    op clearDatabase : DatabaseExt -> DatabaseExt .
    eq clearDatabase({ Cs ; OCs }) = { Cs ; buildInitialOCompExtSet(initState(Cs), type(Cs)) } .

    op evalOCompExtSet : DatabaseExt OCompExtSet -> DatabaseExt .

    eq evalOCompExtSet({ Cs ; OCs }, (Oc , OCs'))
    = evalOCompExtSet($evalOCompExtSet({ Cs ; OCs }, Oc), OCs') .
    eq evalOCompExtSet({ Cs ; OCs }, emptyOCompExt) = { Cs ; OCs } .

    op $evalOCompExtSet : DatabaseExt OCompExt -> DatabaseExt .
    eq $evalOCompExtSet({ Cs ; ((depthList: NL), OCs) }, (depthList: NL'))
    = { Cs ; (depthList: NL'), OCs } .
    eq $evalOCompExtSet({ Cs ; ((currentDepth: N), OCs) }, (currentDepth: N'))
    = { Cs ; (currentDepth: N'), OCs } .
    eq $evalOCompExtSet({ Cs ; ((nodeSet: NS), OCs) }, (nodeSet: NS'))
    = { Cs ; ((nodeSet: NS'), OCs) } .
    eq $evalOCompExtSet({ Cs ; ((result: R4C), OCs) }, (result: R4C'))
    = { Cs ; ((result: R4C'), OCs) } .

    op buildInitialOCompExtSet : Term FormulaType -> OCompExtSet .
    eq buildInitialOCompExtSet(T, FT)
    = (depthList: nil), (currentDepth: 0), (result: nil),
    if FT == eventual then
        ( nodeSet: < < emptyTermSet : addDepthToTerm(T) > : nil > )
    else
        ( nodeSet: < < addDepthToTerm(T) : emptyTermSet > : nil > )
    fi .

    op getNumberOfStates : NodeSet -> Nat .
    op getNumberOfCxStates : NodeSet -> Nat .
    eq getNumberOfStates((ND , NS)) = | states(states&CxStates(ND)) | + getNumberOfStates(NS) .
    eq getNumberOfStates(empty) = 0 .
    eq getNumberOfCxStates((ND , NS)) = | cxStates(states&CxStates(ND)) | + getNumberOfCxStates(NS) .
    eq getNumberOfCxStates(empty) = 0 .

    op findNextDepth : Nat NatList -> Bound .
    eq findNextDepth(N, NL) = $findNextDepth(N, NL, 0) .

    op $findNextDepth : Nat NatList Nat -> Bound .
    eq $findNextDepth(N, nil, N'') = unbounded .
    eq $findNextDepth(N, (N' NL), N'') = if N'' == N and N'' + N' > N
                                        then N'' + N'
                                        else $findNextDepth(N, NL, N' + N'')
                                        fi .

    op getInitialState : DatabaseExt -> State .
    ceq getInitialState(DB-EXT) = ( addDepthToTerm(initState(getConfigExtSet(DB-EXT))),
        if type(Cs) == eventual then cx else all fi,
        0,
        findNextDepth(0, depthList(getOCompExtSet(DB-EXT))),
        nil)
    if not isEmptyDatabaseExt(DB-EXT)
    /\ Cs := getConfigExtSet(DB-EXT) .
    eq getInitialState(DB-EXT) = null [owise] .

    op buildState : DatabaseExt State Term StateType -> State .
    eq buildState(DB-EXT, ST, T, STYPE) = (T,
    STYPE,
    getNextDepth(ST),
    findNextDepth(getNextDepth(ST), depthList(getOCompExtSet(DB-EXT))),
    (< getState(ST) : getNextDepth(ST) > getLog(ST))
    ) .

    op extractFormula : EquationSet Term -> Term .
    ceq extractFormula(((eq T1 = T2 [ A:AttrSet ] .) EQS:EquationSet), T) = T2 if T1 == T .
    eq extractFormula(EQS:EquationSet, T) = 'nil [owise] .

    op buildFormulaConfig : Term -> ConfigExtSet [memo] .
    --- for conditional stable model checking
    eq buildFormulaConfig('_|->_[T1:Term, '`[`]_[T2:Term]])
    =   (type: cstable),
        (ncxFormula: ('_|->_[T1:Term, '<>_[T2:Term]])),
        (cxFormula: ('<>_['`[`]_[T2:Term]])),
        (midFormula: T1:Term) .

    --- for leadsTo model checking
    eq buildFormulaConfig('_|->_[Prop1:Constant, Prop2:Constant])
    =   (type: leadsTo),
        (ncxFormula: ('_|->_[Prop1:Constant, Prop2:Constant])),
        (cxFormula: ('<>_[Prop2:Constant])),
        (eventuallyProp: Prop2:Constant) .

    --- for eventual model checking
    eq buildFormulaConfig('<>_[Prop:Constant])
    =   (type: eventual),
        (cxFormula: ('<>_[Prop:Constant])),
        (eventuallyProp: Prop:Constant) .
endfm

view DatabaseExt from TRIV to DATABASE-EXT is
    sort Elt to DatabaseExt .
endv

fmod CHECKER is
    pr DATABASE-EXT .
    pr TERMSET-EXT .
    pr 2TUPLE{NodeSet,States&CxStates} * (
        op `(_`,_`) to <_:_>,
        op p1_ to ns,
        op p2_ to cache,
        sort Tuple{NodeSet,States&CxStates} to NodeSet&Cache) .

    pr 2TUPLE{TermSet,Nat} * (
        op p1_ to getStates,
        op p2_ to getCount,
        sort Tuple{TermSet,Nat} to GenState) .

    pr 2TUPLE{TermSet,Module} * (
        op p1_ to getCxState,
        op p2_ to getModule,
        sort Tuple{TermSet,Module} to GenCxState) .

    pr 2TUPLE{States&CxStates,Nat} * (
        op `(_`,_`) to <_:_>,
        op p1_ to states&CxStates,
        op p2_ to getCount,
        sort Tuple{States&CxStates,Nat} to GenAll&CxState) .

    pr TRANSITION-TERM-LIST .

    vars M : Module .
    vars NS NS' NS1 NS2 : NodeSet .
    vars ND : Node .
    vars N D C N1 N2 : Nat .
    vars B : Bound .
    vars L : NatList .
    vars LL : LogList .
    vars NeLL : NeLogList .
    vars DB-EXT : DatabaseExt .
    vars Cs : ConfigExtSet .
    vars OCs : OCompExtSet .
    vars T T' T1 T2 F P Cx : Term .
    vars RT : ResultTriple .
    vars TS TS1 TS2 : TermSet .
    vars STATES CxSTATES : TermSet .
    vars R4C : Result4Checking? .
    vars CACHE : States&CxStates .
    vars NS&CACHE : NodeSet&Cache .
    vars Q : Qid .

    --- NodeSet : [Node]+ , empty .
    --- Node : < < ALLStates : ALLCxStates > : < Term : Depth > | nil > >
    --- ALLStates :: TermSet : T1 | T2 | emptyTermSet
    --- ALLCxStates :: TermSet : T1 | T2 | emptyTermSet
    op buildStateSet : Nat NodeSet -> StateSet .
    eq buildStateSet(D, empty) = empty .
    eq buildStateSet(D, (ND , NS)) = $buildStateSet(D, ND), buildStateSet(D, NS) .

    op $buildStateSet : Nat Node -> StateSet .
    eq $buildStateSet(D, < < emptyTermSet : emptyTermSet > : LL >) = empty .
    eq $buildStateSet(D, < < T | TS1 : TS2 > : LL >) =
        (T, all, D, unbounded, LL), $buildStateSet(D, < < TS1 : TS2 > : LL >) .
    eq $buildStateSet(D, < < emptyTermSet : T | TS2 > : LL >) =
        (T, cx, D, unbounded, LL), $buildStateSet(D, < < emptyTermSet : TS2 > : LL >) .

    op collect : Module NodeSet NatList Nat ConfigExtSet -> NodeSet .
    eq collect(M, NS, L, D, Cs) = $collect(M, NS, L, D, Cs) .

    --- update depth in module by stack up depth at each layer before execution
    op $collect : Module NodeSet NatList Nat ConfigExtSet -> NodeSet .
    eq $collect(M, NS, N L, D, Cs) = $collect(M, layerCheck(changeDepth(M, D + N), NS, D + N, N, Cs), L, D + N, Cs) .
    eq $collect(M, NS, nil, D, Cs) = NS .

    --- Node : < < ALLStates : ALLCxStates > : < Term : Depth > | nil > >
    --- ALLStates :: TermSet : T1 | T2 | emptyTermSet
    --- NodeSet : [Node]+ , empty .
    op layerCheck : Module NodeSet Nat Nat ConfigExtSet  -> NodeSet .
    eq layerCheck(M, NS, D, N, Cs) = $layerCheck(M, NS, D, N, empty, < emptyTermSet : emptyTermSet >, Cs) .

    op $layerCheck : Module NodeSet Nat Nat NodeSet States&CxStates ConfigExtSet -> NodeSet .
    eq $layerCheck(M, empty, D, N, NS, CACHE, Cs) = if type(Cs) == cstable then
                                                        filterValidNode(filterByCxStates(NS, cxStates(CACHE)))
                                                    else
                                                        NS
                                                    fi .
    ceq $layerCheck(M, (ND , NS1), D, N, NS2, CACHE, Cs) = $layerCheck(
                                                M,
                                                NS1,
                                                D,
                                                N,
                                                union(NS2, ns(NS&CACHE)),
                                                cache(NS&CACHE),
                                                Cs
                                            ) if NS&CACHE := layerCheck*(M, ND, D, N, CACHE, Cs) .

    ************** apply for each kind of property **************
    op layerCheck* : Module Node Nat Nat States&CxStates ConfigExtSet -> NodeSet&Cache .
    eq layerCheck*(M, ND, D, N, CACHE, Cs) = if type(Cs) == cstable
                                            then
                                                layerCheckForStable(M, ND, D, N, empty, CACHE, Cs)
                                            else
                                                $$layerCheck(M, ND, D, empty, CACHE, Cs)
                                            fi .

    ************** layer check for leadsTo and eventual model checking **************
    op $$layerCheck : Module Node Nat NodeSet States&CxStates ConfigExtSet -> NodeSet&Cache .
    eq $$layerCheck(M, < < emptyTermSet : emptyTermSet > : LL >, N, NS, CACHE, Cs) = < NS : CACHE > .
    ceq $$layerCheck(M, < < T | TS1 : TS2 > : LL >, N, NS, CACHE, Cs) = $$layerCheck(
                                                                M,
                                                                < < TS1 : TS2 > : LL >,
                                                                N,
                                                                union(
                                                                    NS,
                                                                    filterValidNode(
                                                                        < < (STATES except states(CACHE)) : (CxSTATES except cxStates(CACHE)) > : (< T : N > LL) >
                                                                    )
                                                                ),
                                                                < (STATES | states(CACHE)) : (CxSTATES | cxStates(CACHE)) >,
                                                                Cs
                                                            )
                                                            if STATES := genTermSet(M, T, N, Cs)
                                                            /\ CxSTATES := allCounterExample(M, T, ncxFormula(Cs), eventuallyProp(Cs)) .

    ceq $$layerCheck(M, < < emptyTermSet : T | TS2 > : LL >, N, NS, CACHE, Cs) = $$layerCheck(
                                                                M,
                                                                < < emptyTermSet : TS2 > : LL >,
                                                                N,
                                                                union(NS,
                                                                    filterValidNode(
                                                                        < < emptyTermSet : (CxSTATES except cxStates(CACHE)) > : (< T : N > LL) >
                                                                    )
                                                                ),
                                                                < states(CACHE) : (CxSTATES | cxStates(CACHE)) >,
                                                                Cs
                                                            ) if CxSTATES := allCounterExample(M, T, cxFormula(Cs), eventuallyProp(Cs)) .

    ************** layer check for conditional stable model checking **************
    op layerCheckForStable : Module Node Nat Nat NodeSet States&CxStates ConfigExtSet -> NodeSet&Cache .
    eq layerCheckForStable(M, < < emptyTermSet : emptyTermSet > : LL >, D, N, NS, CACHE, Cs) = < NS : CACHE > .
    ceq layerCheckForStable(M, < < T | TS1 : TS2 > : LL >, D, N, NS, CACHE, Cs) = layerCheckForStable(
                                                                M,
                                                                < < TS1 : TS2 > : LL >,
                                                                D,
                                                                N,
                                                                union(
                                                                    NS,
                                                                    filterValidNode(
                                                                        < < (STATES except states(CACHE)) : (CxSTATES except cxStates(CACHE)) > : (< T : D > LL) >
                                                                    )
                                                                ),
                                                                < (STATES | states(CACHE)) : (CxSTATES | cxStates(CACHE)) >,
                                                                Cs
                                                            )
                                                            if < STATES : CxSTATES > := genStatesForStable(M, T, D, N, Cs) .

    ceq layerCheckForStable(M, < < emptyTermSet : T | TS2 > : LL >, D, N, NS, CACHE, Cs) = layerCheckForStable(
                                                                M,
                                                                < < emptyTermSet : TS2 > : LL >,
                                                                D,
                                                                N,
                                                                union(NS,
                                                                    filterValidNode(
                                                                        < < emptyTermSet : (CxSTATES except cxStates(CACHE)) > : (< T : D > LL) >
                                                                    )
                                                                ),
                                                                < states(CACHE) : (CxSTATES | cxStates(CACHE)) >,
                                                                Cs
                                                            ) if CxSTATES := genTermSet(M, T, D, Cs) .

    --- Accept only either ALLStates or ALLCxStates are not empty
    op filterValidNode : NodeSet -> NodeSet .
    eq filterValidNode(empty) = empty .
    eq filterValidNode((< < TS1 : TS2 > : LL > , NS)) = if (| TS1 | == 0 and | TS2 | == 0)
                                                    then
                                                        filterValidNode(NS)
                                                    else
                                                        (< < TS1 : TS2 > : LL > , filterValidNode(NS))
                                                    fi .

    --- filter Non-CxStates by CxStates in NodeSet
    op filterByCxStates : NodeSet TermSet -> NodeSet .
    eq filterByCxStates(empty, TS) = empty .
    eq filterByCxStates((< < TS1 : TS2 > : LL > , NS), TS) = < < TS1 except TS : TS2 > : LL >,  filterByCxStates(NS, TS) .

    ************ GET ALL STATES AT A DEPTH ************
    op genTermSet : Module Term Nat ConfigExtSet -> TermSet .
    eq genTermSet(M, empty, D, Cs) = emptyTermSet .
    eq genTermSet(M, T, 0, Cs) = emptyTermSet .
    ceq genTermSet(M, T, D, Cs) = $genTermSet(
        metaSearch(M, T, Q['__[getVarTerm(soupSort(Cs)), 'depth:_[upTerm(D)]]], nil, '*, unbounded, 0),
        M,
        T,
        D,
        0,
        Cs
    )
    if Q := extractOidFromTerm(T) .

    op $genTermSet : ResultTriple? Module Term Nat Nat ConfigExtSet -> TermSet .
    eq $genTermSet(failure, M, T, D, N, Cs) = emptyTermSet .
    ceq $genTermSet(RT, M, T, D, N, Cs) = getTerm(RT) | $genTermSet(
        metaSearch(M, T, Q['__[getVarTerm(soupSort(Cs)), 'depth:_[upTerm(D)]]], nil, '*, unbounded, N + 1),
        M,
        T,
        D,
        N + 1,
        Cs
    )
    if Q := extractOidFromTerm(T) .

    ************ GET ALL COUNTEREXAMPLE STATES AT A DEPTH ************
    --- Build Equations to add to Module to ignore in next finding counterexample
    op buildEqs : Term Term -> EquationSet .
    eq buildEqs(T, P) = (eq '_|=_[T, P] = 'true.Bool [none] .) .
    --- eq buildEqs(T, P) = (eq '_|=_[T, 'inCs1.Prop] = 'true.Bool [none] .) .


    op allCounterExample : Module Term Term Term -> TermSet .
    --- generate all counterexamples by modelCheckAll
    --- ceq allCounterExample(M, T, F, P) = if (Cx :: Constant)
    ---                                     then emptyTermSet
    ---                                     else
    ---                                         handleCounterExample(Cx)
    ---                                     fi
    ---                                     if Cx := getReducedTerm(M, 'modelCheckAll[T, F]) .
    --- eq allCounterExample(M, T, F, P) = emptyTermSet [owise] .
    --- op handleCounterExample : Term -> TermSet .
    --- eq handleCounterExample('_|_[TL]) = handleCounterExample*(TL) .
    --- eq handleCounterExample('counterexample[TL]) = getTopTerm(getCounterExampleState('counterexample[TL])) .

    --- op handleCounterExample* : TermList -> TermSet .
    --- ceq handleCounterExample*((T, TL)) = getTopTerm(TL') | handleCounterExample*(TL) if TL' := getCounterExampleState(T) .
    --- eq handleCounterExample*(empty) = emptyTermSet .

    --- generate all counterexamples manually
    eq allCounterExample(M, T, F, P) = $allCounterExample(M, T, F, P) .
    op $allCounterExample : Module Term Term Term -> TermSet .
    ceq $allCounterExample(M, T, F, P) = if (Cx :: Constant)
                                    then emptyTermSet
                                    else
                                        getTopTerm(getCounterExampleState(Cx)) | $allCounterExample(addEqs(buildEqs(getCounterExampleState(Cx), P), M), T, F, P)
                                    fi
                                    if Cx := getReducedTerm(M, 'modelCheck[T, F]) .
    eq $allCounterExample(M, T, F, P) = emptyTermSet [owise] .

    op getCounterExampleState : Term -> TermList .
    eq getCounterExampleState(T) = topTL(extractTL(lastTL(extractTL(T)))) .

    --- Checking some state at the last layer for approximation
    --- 1st: total node set
    --- 2nd: number of states
    --- 3rd: number of cx states
    op selectStates : NodeSet Nat Nat -> NodeSet .
    eq selectStates(NS, N1, N2) = pickStates(NS, N1) , pickCxStates(NS, N2) .
    op pickStates : NodeSet Nat -> NodeSet .
    eq pickStates((NS, < < T | TS1 : TS2 > : LL >, NS'), N1) =
    if N1 > 0 then
        < < T : emptyTermSet > : LL >, pickStates((NS, < < TS1 : TS2 > : LL >, NS'), sd(N1,1))
    else
        empty
    fi .
    eq pickStates(NS, N1) = empty [owise] .

    op pickCxStates : NodeSet Nat -> NodeSet .
    eq pickCxStates((NS, < < TS1 : T | TS2 > : LL >, NS'), N2) =
    if N2 > 0 then
        < < emptyTermSet : T > : LL >, pickCxStates((NS, < < TS1 : TS2 > : LL >, NS'), sd(N2,1))
    else
        empty
    fi .
    eq pickCxStates(NS, N2) = empty [owise] .

    --- Logic checking at the last layer with unbounded
    op lastLayerCheck : Module NodeSet ConfigExtSet -> Result4Checking? .
    eq lastLayerCheck(M, empty, Cs) = success .
    ceq lastLayerCheck(M, (ND , NS), Cs) = if R4C :: Result4Checking
                                        then
                                            lastLayerCheck(M, NS, Cs)
                                        else
                                            R4C
                                        fi
                                        if R4C := checkNode(M, ND, Cs) .

    --- Check all states in ALLStates one by one
    op checkStates : Module TermSet LogList ConfigExtSet -> Result4Checking? .
    eq checkStates(M, emptyTermSet, LL, Cs) = success .
    ceq checkStates(M, T | TS, LL, Cs) = if (Cx :: Constant)
                                    then checkStates(M, TS, LL, Cs)
                                    else
                                        {formula: F, term: T', trace: (< T : 0 > LL), cx: Cx}
                                    fi
                                    if T' := removeDepthFromTerm(T)
                                    /\ F := ncxFormula(Cs)
                                    /\ Cx := getReducedTerm(M, 'modelCheck[T', F]) .

    --- Check counterexample in ALLCxStates one by one
    op checkCxStates : Module TermSet LogList ConfigExtSet -> Result4Checking? .
    eq checkCxStates(M, emptyTermSet, LL, Cs) = success .
    ceq checkCxStates(M, T | TS, LL, Cs) = if (Cx :: Constant)
                                        then checkCxStates(M, TS, LL, Cs)
                                        else {formula: F, term: T', trace: (< T : 0 > LL), cx: Cx}
                                        fi
                                        if T' := removeDepthFromTerm(T)
                                        /\ F := cxFormula(Cs)
                                        /\ Cx := getReducedTerm(M, 'modelCheck[T', F]) .

    --- Check counterexample in a Node one by one in order, including both ALLStates and ALLCxStates
    op checkNode : Module Node ConfigExtSet -> Result4Checking? .
    ceq checkNode(M, ND, Cs) = if (R4C :: Result4Checking)
                    then checkCxStates(M, cxStates(states&CxStates(ND)), logList(ND), Cs)
                    else R4C
                    fi
                    if R4C := checkStates(M, states(states&CxStates(ND)), logList(ND), Cs) .
    eq checkNode(M, ND, Cs) = success [owise] .

    ************ FOR STABLE MODEL CHECKING ************
    vars STL : Set{TermList} .
    vars TL TL' : TermList .

    op genStatesForStable : Module Term Nat Nat ConfigExtSet -> States&CxStates .
    eq genStatesForStable(M, T, D, N, Cs) = genStatesForStable*(M, Cs, genStateSeqs(M, T, N), < emptyTermSet : emptyTermSet >) .

    op genStatesForStable* : Module ConfigExtSet Set{TermList} States&CxStates -> States&CxStates .
    op genStatesForStable** : Module ConfigExtSet TermList States&CxStates -> States&CxStates .

    eq genStatesForStable*(M, Cs, emp, < TS1 : TS2 >) = < TS1 : TS2 > .
    eq genStatesForStable*(M, Cs, (TL || STL), < TS1 : TS2 >) = genStatesForStable*(M, Cs, STL, genStatesForStable**(M, Cs, TL, < TS1 : TS2 >)) .

    eq genStatesForStable**(M, Cs, empty, < TS1 : TS2 >) = < TS1 : TS2 > .
    eq genStatesForStable**(M, Cs, (T, TL), < TS1 : TS2 >)
    =   if checkStateSeq(M, Cs, (T, TL)) then
            < TS1 except T : TS2 | T >
            --- < TS1 : TS2 | T >
        else
            if T in TS2 then < TS1 : TS2 > else < T | TS1 : TS2 > fi
            --- < T | TS1 : TS2 >
        fi
    .

    op checkStateSeq : Module ConfigExtSet TermList -> Bool .
    eq checkStateSeq(M, Cs, empty) = false .

    ceq checkStateSeq(M, Cs, (T, TL))
    = if B:Bool
        then true
        else checkStateSeq(M, Cs, TL)
        fi
    if B:Bool := downTerm(getTerm(metaReduce(M, '_|=_[T, midFormula(Cs)])), b-error) .

    ************ BUILDING GLOBAL COUNTEREXAMPLE ************
    vars TTL : TransitionTermList .
    vars TT : TransitionTerm .

    op getCounterExample : Module Result4Checking? -> Term .
    eq getCounterExample(M, R4C) = combineCounterExample(reverse(buildCounterExample(M, reverse(getLogList(R4C)))), getCx(R4C)) .

    op traceStepTerm : TraceStep -> Term .
    op traceStepRule : TraceStep -> Rule .
    eq traceStepTerm({ T:Term, T:Type, R:Rule }) = T:Term .
    eq traceStepRule({ T:Term, T:Type, R:Rule }) = R:Rule .

    op ruleLabel : Rule -> Term .
    eq ruleLabel(rl T1:Term => T2:Term [ label(Q:Qid) ].) = Q:Qid .
    eq ruleLabel(crl T1:Term => T2:Term if C:Condition [ label(Q:Qid) ].) = Q:Qid .


    op getQidTerm : Qid -> Term .
    eq getQidTerm(Q) = getTerm(metaParse(upModule('QID, false), qid("'" + string(Q)), 'Qid)) .

    op getTransitionList : Trace -> TransitionTermList .
    eq getTransitionList(nil) = nil .
    eq getTransitionList(TS:TraceStep T:Trace) = < traceStepTerm(TS:TraceStep), getQidTerm(ruleLabel(traceStepRule(TS:TraceStep))) > getTransitionList(T:Trace) .

    op getTrace : Module Term Term Nat -> Trace .
    ceq getTrace(M, T1, T2, N) = if T:Trace? == failure
                            then nil
                            else T:Trace?
                            fi
                            if T:Trace? := metaSearchPath(M, T1, T2, nil, '*, unbounded, 0) [print "\nTrace " T:Trace? ] .

    op buildCounterExample : Module LogList -> TransitionTermList .
    eq buildCounterExample(M, nil) = nil .
    eq buildCounterExample(M, < T : N > LL) = $buildCounterExample(M, T, LL, nil, N) .

    op $buildCounterExample : Module Term LogList TransitionTermList Nat -> TransitionTermList .
    eq $buildCounterExample(M, T, nil, TTL, D) = TTL .
    eq $buildCounterExample(M, T1, < T2 : N > LL, TTL, D) = $buildCounterExample(
        M, T2, LL,
        reverse(getTransitionList(getTrace(changeDepth(M, D), T1, T2, D))) TTL,
        D + N
    ) [print "\nT1 = " T1 "\n T2" T2 "\n D " D].

    op transformTransitionTermList : TransitionTermList -> TermList .
    eq transformTransitionTermList(nil) = empty .
    eq transformTransitionTermList(TT TTL) = '`{_`,_`}[removeDepthFromTerm(getState(TT)), getLabel(TT)], transformTransitionTermList(TTL) [print "TT " TT] .

    op combineCounterExample : TransitionTermList Term -> Term .
    eq combineCounterExample(TTL, 'counterexample['__[TL1:TermList], TL2:TermList]) = 'counterexample['__[transformTransitionTermList(TTL), TL1:TermList], TL2:TermList] .
    eq combineCounterExample(TTL, 'counterexample[TL1:TermList, TL2:TermList]) = 'counterexample['__[transformTransitionTermList(TTL), TL1:TermList], TL2:TermList] [owise] .

    ************ PROCESS STATES AT A DEPTH ************
    --- process all states with batch
    op procGenAllStates : Module Term Nat ConfigExtSet Nat Bound -> GenState .
    eq procGenAllStates(M, T, D, Cs, C, B) = $procGenAllStates(changeDepth(M, D), T, D, Cs, C, B, emptyTermSet, 0) .

    op $procGenAllStates : Module Term Nat ConfigExtSet Nat Bound TermSet Nat -> GenState .
    ceq $procGenAllStates(M, T, D, Cs, C, B, TS, N) = $procGenAllStates(M, T, D, Cs, C + 1, B, getTerm(RT) | TS, N + 1)
                                                        if B == unbounded /\ RT := genState(M, T, D, Cs, C) .

    ceq $procGenAllStates(M, T, D, Cs, C, B, TS, N) = $procGenAllStates(M, T, D, Cs, C + 1, B, getTerm(RT) | TS, N + 1)
                                                        if B =/= unbounded /\ N < B /\ RT := genState(M, T, D, Cs, C) .
    eq $procGenAllStates(M, T, D, Cs, C, B, TS, N) = (TS, C) [owise] .

    op genState : Module Term Nat ConfigExtSet Nat -> ResultTriple? .
    ceq genState(M, T, D, Cs, C) = metaSearch(M, T, Q['__[getVarTerm(soupSort(Cs)), 'depth:_[upTerm(D)]]], nil, '*, unbounded, C)
    if Q := extractOidFromTerm(T) .


    --- process counterexample states with batch
    op procGenCxStates : Module Term Nat ConfigExtSet Bound StateType -> GenCxState .
    eq procGenCxStates(M, T, D, Cs, B, all) = $procGenCxStates(changeDepth(M, D), T, D, ncxFormula(Cs), eventuallyProp(Cs), B, emptyTermSet, 0) .
    eq procGenCxStates(M, T, D, Cs, B, cx) = $procGenCxStates(changeDepth(M, D), T, D, cxFormula(Cs), eventuallyProp(Cs), B, emptyTermSet, 0) .

    --- processes for leadsTo and eventual properties
    op $procGenCxStates : Module Term Nat Term Term Bound TermSet Nat -> GenCxState .
    ceq $procGenCxStates(M, T, D, F, P, B, TS, N) = if Cx :: Constant
                                                then (TS, M)
                                                else $procGenCxStates(addEqs(buildEqs(getCounterExampleState(Cx), P), M), T, D, F, P, B, getCounterExampleState(Cx) | TS, N + 1)
                                                fi
                                            if B == unbounded
                                            /\ Cx := getReducedTerm(M, 'modelCheck[T, F]) .

    ceq $procGenCxStates(M, T, D, F, P, B, TS, N) = if Cx :: Constant
                                                    then (TS, M)
                                                    else $procGenCxStates(addEqs(buildEqs(getCounterExampleState(Cx), P), M), T, D, F, P, B, getCounterExampleState(Cx) | TS, N + 1)
                                                    fi
                                                if B =/= unbounded
                                                /\ N < B
                                                /\ Cx := getReducedTerm(M, 'modelCheck[T, F]) .

    eq $procGenCxStates(M, T, D, F, P, B, TS, N) = (TS, M) [owise] .
endfm