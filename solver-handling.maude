mod SOLVER-DATABASE-HANDLING is
    inc FM-DATABASE-HANDLING .
    pr SOLVER-COMMAND-PROCESSING .
    pr SOLVER-HELP .
    pr SOLVER-MESSAGE .

    op db-ext :_ : DatabaseExt -> Attribute .

    vars T T' T'' : Term .
    vars T1 T2 T3 T4 T5 : Term .
    vars ME ME' : ModuleExpression .
    vars DB DB' DB'' : Database .
    var Atts : AttributeSet .
    var X@DatabaseClass : DatabaseClass .
    vars O O' O'' : Oid .
    var DB-EXT DB-EXT' : DatabaseExt .
    var QIL : QidList .
    var RES : Tuple{Database,QidList,DatabaseExt} .
    var ST : State .
    var STYPE : StateType .
    vars M M' : Module .
    vars OCs OCs' : OCompExtSet .
    vars Cs Cs' : ConfigExtSet .
    vars D N N' C C' : Nat .
    vars B : Bound .
    vars GS : GenState .
    vars GCxS : GenCxState .
    vars TS TS1 TS2 : TermSet .
    vars R4C : Result4Checking? .
    vars L L' : Logger .
    vars BL : Bool .

    crl [initialize] :
        < O : X@DatabaseClass | db : DB,
            input : ('initialize`[_`,_`,_`,_`,_`][T, T1, T2, T3, T4]),
            output : nil,
            db-ext : DB-EXT,
            default : ME,
            status : idle,
            Atts >
     => < O : X@DatabaseClass |
            db : getDatabase(RES),
            input : nilTermList,
            output : getQidList(RES),
            db-ext : getDatabaseExt(RES),
            default : parseHeader(T),
            status : initialized,
            Atts >
            if RES := procInitializeCommand('initialize`[_`,_`,_`,_`,_`][T, T1, T2, T3, T4], ME, DB, DB-EXT) .

    crl [layerCheck] :
        < O : X@DatabaseClass |
            db : DB,
            input : ('layerCheck_[T]),
            output : nil,
            db-ext : DB-EXT,
            default : ME, Atts >
        => < O : X@DatabaseClass |
            db : getDatabase(RES),
            input : nilTermList,
            output : getQidList(RES),
            db-ext : getDatabaseExt(RES),
            default : ME, Atts >
            if RES := procLayerCheckCommand('layerCheck_[T], ME, DB, DB-EXT) .

    crl [serverDepthInfo] :
        < O : X@DatabaseClass |
            db : DB,
            input : ('depthInfo_[T]),
            output : nil,
            db-ext : DB-EXT,
            default : ME,
            status : initialized,
            server : O',
            isAll : BL,
            cache : O'', Atts >
        => < O : X@DatabaseClass |
            db : DB',
            input : nilTermList,
            output : getQidList(RES),
            db-ext : DB-EXT',
            default : ME,
            status : waiting,
            server : O',
            cache : O'',
            isAll : BL,
            Atts >
            if BL then
                lookupReq(O'', O, getInitialState(DB-EXT'))
            else
                lookupBatchReply(O', O, buildStateSet(
                    sum(depthList(OCs)),
                    collect(M', nodeSet(OCs), depthList(OCs), currentDepth(OCs), Cs)
                ))
            fi
            if RES := procDepthInfoCommand('depthInfo_[T], ME, DB, DB-EXT)
            /\ DB' := getDatabase(RES)
            /\ DB-EXT' := getDatabaseExt(RES)
            /\ M := getFlatModule(ME, DB')
            /\ Cs := getConfigExtSet(DB-EXT')
            /\ OCs := getOCompExtSet(DB-EXT')
            /\ M' := getFlatModule(reviseModule(Cs), DB') .

    crl [clientDepthInfo] :
        < O : X@DatabaseClass |
            db : DB,
            input : ('depthInfo_[T]),
            output : nil,
            db-ext : DB-EXT,
            default : ME,
            status : initialized,
            client : O',
            cache : O'', Atts >
        => < O : X@DatabaseClass |
            db : getDatabase(RES),
            input : nilTermList,
            output : getQidList(RES),
            db-ext : getDatabaseExt(RES),
            default : ME,
            status : waiting,
            client : O',
            cache : O'', Atts >
            if RES := procDepthInfoCommand('depthInfo_[T], ME, DB, DB-EXT) .

    crl [handle] :
        < O : X@DatabaseClass |
            db : DB,
            db-ext : DB-EXT,
            input : nilTermList,
            status : waiting,
            client : O'',
            logger : L,
            Atts >
        handle(O, O', ST)
        =>
        < O : X@DatabaseClass |
            db : DB,
            db-ext : DB-EXT,
            input : nilTermList,
            status : working,
            client : O'',
            logger : L',
            Atts >
        if getType(ST) == all
        then
            if getNextDepth(ST) =/= unbounded
            then
                if type(Cs) == cstable then
                    genStatesForStable(O, ST, M)
                else
                    genAllStates(O, ST, M, 0)
                fi
            else
                lastCheckAllState(O, ST)
            fi
        else
            if getNextDepth(ST) =/= unbounded
            then
                if type(Cs) == cstable then
                    genCxStatesForStable(O, ST, M, 0)
                else
                    genCxStates(O, ST, M)
                fi
            else
                lastCheckCxState(O, ST)
            fi
        fi
        if Cs := getConfigExtSet(DB-EXT)
        /\ M := getFlatModule(reviseModule(Cs), DB)
        /\ L' := logging(L, getDepth(ST), getType(ST))
        /\ N := getDepth(ST)
        /\ B := getNextDepth(ST)
        [print "[handle] State at Depth = " N " nextDepth = " B " Logger = " L'] .

    --- for conditional stable properties
    crl [genStatesForStable] :
        < O : X@DatabaseClass |
            db : DB,
            db-ext : DB-EXT,
            status : working,
            cache : O',
            client : O'',
            Atts >
        genStatesForStable(O, ST, M)
        =>
        < O : X@DatabaseClass |
            db : DB,
            db-ext : DB-EXT,
            status : suspending,
            cache : O',
            client : O'',
            Atts >
        genStatesForStableDone(O, ST, M)
        lookupBatchReq(O', O, (termSetToStates(DB-EXT, ST, TS1, all), termSetToStates(DB-EXT, ST, TS2, cx)))
        if Cs := getConfigExtSet(DB-EXT)
        /\ D := getNextDepth(ST)
        /\ N := sd(D, getDepth(ST))
        /\ < TS1 : TS2 > := genStatesForStable(changeDepth(M, D) , getState(ST), D, N, Cs)
        /\ C := | TS1 |
        /\ C' := | TS2 |
        [print "[genStatesForStable] |TS1| = " C " |TS2| = " C'] .

    rl [genStatesForStableDone] :
        < O : X@DatabaseClass |
            status : working,
            client : O'',
            Atts >
        genStatesForStableDone(O, ST, M)
        =>
        < O : X@DatabaseClass |
            status : waiting,
            client : O'',
            Atts >
        fetchState(O'', O)
        [print "[genStatesForStableDone]"] .

    crl [genCxStatesForStable] :
        < O : X@DatabaseClass |
            db : DB,
            db-ext : DB-EXT,
            status : working,
            batchSize : B,
            cache : O',
            client : O'',
            Atts >
        genCxStatesForStable(O, ST, M, C)
    =>  if C' > C
        then
            < O : X@DatabaseClass |
                db : DB,
                db-ext : DB-EXT,
                status : suspending,
                batchSize : B,
                cache : O',
                client : O'',
                Atts >
            genCxStatesForStable(O, ST, M, C')
            lookupBatchReq(O', O, termSetToStates(DB-EXT, ST, TS, cx))
        else
            < O : X@DatabaseClass |
                db : DB,
                db-ext : DB-EXT,
                status : waiting,
                batchSize : B,
                cache : O',
                client : O'',
                Atts >
            fetchState(O'', O)
        fi
    if  Cs := getConfigExtSet(DB-EXT)
    /\ GS := procGenAllStates(M, getState(ST), getNextDepth(ST), Cs, C, B) --- generate all states given a state
    /\ C' := getCount(GS)
    /\ TS := getStates(GS) [print "[genCxStatesForStable]"] .
    --- end for conditional stable properties

    crl [genAllStates] :
        < O : X@DatabaseClass |
            db : DB,
            db-ext : DB-EXT,
            input : nilTermList,
            status : working,
            batchSize : B,
            cache : O',
            client : O'',
            Atts >
        genAllStates(O, ST, M, C)
        =>  if C' > C
            then
                < O : X@DatabaseClass |
                    db : DB,
                    db-ext : DB-EXT,
                    input : nilTermList,
                    status : suspending,
                    batchSize : B,
                    cache : O',
                    client : O'',
                    Atts >
                genAllStates(O, ST, M, C')
                lookupBatchReq(O', O, termSetToStates(DB-EXT, ST, TS, all))
            else
                < O : X@DatabaseClass |
                    db : DB,
                    db-ext : DB-EXT,
                    input : nilTermList,
                    status : working,
                    batchSize : B,
                    cache : O',
                    client : O'',
                    Atts >
                genCxStates(O, ST, M)
            fi
        if Cs := getConfigExtSet(DB-EXT)
        /\ GS := procGenAllStates(M, getState(ST), getNextDepth(ST), Cs, C, B)
        /\ C' := getCount(GS)
        /\ TS := getStates(GS) [print "[genAllStates]"] .

    op termSetToStates : DatabaseExt State TermSet StateType -> StateSet .
    eq termSetToStates(DB-EXT, ST, emptyTermSet, STYPE) = empty .
    eq termSetToStates(DB-EXT, ST, T | TS, STYPE) = buildState(DB-EXT, ST, T, STYPE), termSetToStates(DB-EXT, ST, TS, STYPE) .

    crl [genCxStates] :
        < O : X@DatabaseClass |
            db : DB,
            db-ext : DB-EXT,
            input : nilTermList,
            status : working,
            batchSize : B,
            cache : O',
            client : O'',
            Atts >
        genCxStates(O, ST, M)
    =>  if | TS | > 0
        then
            < O : X@DatabaseClass |
                db : DB,
                db-ext : DB-EXT,
                input : nilTermList,
                status : suspending,
                batchSize : B,
                cache : O',
                client : O'',
                Atts >
            genCxStates(O, ST, M')
            lookupBatchReq(O', O, termSetToStates(DB-EXT, ST, TS, cx))
        else
            < O : X@DatabaseClass |
                db : DB,
                db-ext : DB-EXT,
                input : nilTermList,
                status : waiting,
                batchSize : B,
                cache : O',
                client : O'',
                Atts >
            fetchState(O'', O)
        fi
    if  Cs := getConfigExtSet(DB-EXT)
    /\ GCxS := procGenCxStates(M, getState(ST), getNextDepth(ST), Cs, B, getType(ST))
    /\ TS := getCxState(GCxS)
    /\ M' := getModule(GCxS) [print "[genCxStates]"] .

    rl [resumeWorking] :
        < O : X@DatabaseClass |
            status : suspending,
            Atts >
        resumeReq(O, O')
    => < O : X@DatabaseClass |
            status : working,
            Atts > [print "[ResumeWorking]"] .

    crl [lastCheckAllState] :
        < O : X@DatabaseClass |
        db : DB,
        db-ext : DB-EXT,
        input : nilTermList,
        status : working,
        client : O',
        Atts > lastCheckAllState(O, ST)
    => if R4C :: Result4Checking
        then
            < O : X@DatabaseClass |
            db : DB,
            db-ext : DB-EXT,
            input : nilTermList,
            status : waiting,
            client : O',
            Atts >
            fetchState(O', O)
        else
            < O : X@DatabaseClass |
            db : DB,
            db-ext : evalOCompExtSet(DB-EXT, ((result: R4C))),
            input : nilTermList,
            status : stopping,
            client : O',
            Atts >
            buildCx(O, O)
            stopWorking(O', O)
        fi
    if Cs := getConfigExtSet(DB-EXT)
    /\ M := getFlatModule(originModule(Cs), DB)
    /\ R4C := checkStates(M, getState(ST), getLog(ST), Cs)
    [print "[lastCheckAllState] R4C = " R4C] .

    crl [lastCheckCxState] :
        < O : X@DatabaseClass |
        db : DB,
        db-ext : DB-EXT,
        input : nilTermList,
        status : working,
        client : O',
        Atts > lastCheckCxState(O, ST)
    => if R4C :: Result4Checking
        then
            < O : X@DatabaseClass |
            db : DB,
            db-ext : DB-EXT,
            input : nilTermList,
            status : waiting,
            client : O',
            Atts >
            fetchState(O', O)
        else
            < O : X@DatabaseClass |
            db : DB,
            db-ext : evalOCompExtSet(DB-EXT, ((result: R4C))),
            input : nilTermList,
            status : stopping,
            client : O',
            Atts >
            buildCx(O, O)
            stopWorking(O', O)
        fi
    if Cs := getConfigExtSet(DB-EXT)
    /\ M := getFlatModule(originModule(Cs), DB)
    /\ R4C := checkCxStates(M, getState(ST), getLog(ST), Cs)
    [print "[lastCheckCxState] R4C = " R4C] .

    crl [buildCxState] :
        < O : X@DatabaseClass |
        db : DB,
        db-ext : DB-EXT,
        status : stopping,
        Atts > buildCx(O, O')
    => < O : X@DatabaseClass |
        db : DB,
        db-ext : DB-EXT,
        status : stopping,
        Atts >
        counterexample(O, T)
    if Cs := getConfigExtSet(DB-EXT)
    /\ OCs := getOCompExtSet(DB-EXT)
    /\ M := getFlatModule(reviseModule(Cs), DB)
    /\ R4C := result(OCs)
    /\ not R4C :: Result4Checking
    /\ T := getCounterExample(M, R4C)
    [print "[buildCxState] Counterexample = " T] .

    crl [lastCheck] :
        < O : X@DatabaseClass |
        db : DB,
        input : ('lastCheck.@Command@),
        output : nil,
        db-ext : DB-EXT,
        default : ME, Atts >
        => < O : X@DatabaseClass |
        db : DB,
        input : nilTermList,
        output : getQidList(RES),
        db-ext : getDatabaseExt(RES),
        default : ME, Atts >
        if RES := procLastCheckCommand('lastCheck.@Command@, ME, DB, DB-EXT) .

    crl [check] :
        < O : X@DatabaseClass |
            db : DB,
            input : ('check_[T]),
            output : nil,
            db-ext : DB-EXT,
            default : ME, Atts >
        => < O : X@DatabaseClass |
            db : getDatabase(RES),
            input : nilTermList,
            output : getQidList(RES),
            db-ext : getDatabaseExt(RES),
            default : ME, Atts >
            if RES := procCheckCommand('check_[T], ME, DB, DB-EXT) .

    crl [checkWithoutParams] :
        < O : X@DatabaseClass |
        db : DB,
        input : ('check.@Command@),
        output : nil,
        db-ext : DB-EXT,
        default : ME, Atts >
        => < O : X@DatabaseClass |
        db : DB,
        input : nilTermList,
        output : getQidList(RES),
        db-ext : getDatabaseExt(RES),
        default : ME, Atts >
        if RES := procLastCheckCommand('lastCheck.@Command@, ME, DB, DB-EXT) .

    crl [showCx] :
        < O : X@DatabaseClass |
        db : DB,
        input : ('showCx.@Command@),
        output : nil,
        db-ext : DB-EXT,
        default : ME, Atts >
        => < O : X@DatabaseClass |
        db : DB,
        input : nilTermList,
        output : getQidList(RES),
        db-ext : getDatabaseExt(RES),
        default : ME, Atts >
        if RES := procShowCxCommand('showCx.@Command@, ME, DB, DB-EXT) .

    rl [analyze] :
        < O : X@DatabaseClass |
        db : DB,
        input : ('analyze.@Command@),
        output : nil,
        db-ext : DB-EXT,
        default : ME, Atts >
        => < O : X@DatabaseClass |
        db : DB,
        input : nilTermList,
        output : procAnalyzeCommand('analyze.@Command@, ME, DB, DB-EXT),
        db-ext : DB-EXT,
        default : ME, Atts > .

    crl [clear] :
        < O : X@DatabaseClass |
        db : DB,
        input : ('clear.@Command@),
        output : nil,
        db-ext : DB-EXT,
        default : ME, Atts >
        => < O : X@DatabaseClass |
        db : DB,
        input : nilTermList,
        output : getQidList(RES),
        db-ext : getDatabaseExt(RES),
        default : ME, Atts >
        if RES := procClearCommand('clear.@Command@, ME, DB, DB-EXT) .

    rl [solver-help] :
        < O : X@DatabaseClass | input : ('solver-help.@Command@), output : QIL, Atts >
        => < O : X@DatabaseClass | input : nilTermList, output : solver-help, Atts > .
endm