mod SOLVER-APP is
    pr SOLVER-MESSAGE .
    pr LEXICAL .
    pr SOLVER-META-SIGN .
    pr SOLVER-DATABASE-HANDLING .

    vars  Atts : AttributeSet .
    vars  X@DatabaseClass : DatabaseClass .
    vars  O O' : Oid .
    vars  DB : Database .
    vars S DATA : String .
    vars QIL : QidList .
    vars QI ME : Qid .
    vars TL : TermList .
    vars NL : NatList .
    vars ST : State .
    vars R : Request .
    vars L : Logger .

    crl [init] :
        < O : X@DatabaseClass |
            db : DB, input : nilTermList, output : nil, default : ME, Atts >
        initialize(O, S)
        => if metaParse(SOLVER-GRAMMAR, QIL, '@Input@) :: ResultPair
        then < O : X@DatabaseClass | db : DB,
                input : getTerm(metaParse(SOLVER-GRAMMAR, QIL, '@Input@)),
                output : nil, default : ME, Atts >
        else < O : X@DatabaseClass | db : DB, input : nilTermList,
                    output : ('\r 'Warning:
                            printSyntaxError(metaParse(SOLVER-GRAMMAR, QIL, '@Input@),
                                QIL)
                            '\n
                            '\r 'Error: '\o 'No 'parse 'for 'input. '\n),
                    default : ME, Atts >
        fi
        if QIL := tokenize(S) .

    crl [depthInfo] :
        < O : X@DatabaseClass |
            db : DB, input : nilTermList, output : nil, default : ME, Atts >
        depthInfo(O, S)
        => if metaParse(SOLVER-GRAMMAR, QIL, '@Input@) :: ResultPair
        then < O : X@DatabaseClass | db : DB,
                input : getTerm(metaParse(SOLVER-GRAMMAR, QIL, '@Input@)),
                output : nil, default : ME, Atts >
        else < O : X@DatabaseClass | db : DB, input : nilTermList,
                    output : ('\r 'Warning:
                            printSyntaxError(metaParse(SOLVER-GRAMMAR, QIL, '@Input@),
                                QIL)
                            '\n
                            '\r 'Error: '\o 'No 'parse 'for 'input. '\n),
                    default : ME, Atts >
        fi
        if QIL := tokenize(S) .

    rl [error] :
        < O : X@DatabaseClass | Atts >
        error(O, O', R, DATA)
        =>
        < O : X@DatabaseClass | Atts > [print "[error] " R " -> " DATA] .

    rl [out] :
        < O : X@DatabaseClass |
            db : DB, input : TL, output : (QI QIL), default : ME, Atts >
        => < O : X@DatabaseClass |
            db : DB, input : TL, output : nil, default : ME, Atts > [print "[output] " QI " " QIL] .

    rl [clearApp] :
        < O : X@DatabaseClass | logger : L, Atts > clearApp(O, O')
        => if L == empty
        then < O : X@DatabaseClass | none >
        else < O : X@DatabaseClass | logger : L >
        fi .
endm