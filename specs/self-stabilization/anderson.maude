***
***      Start Section
***  ss: place[i] := fetch&incmode(next, N);
***  ws: repeat until array[place[i]];
***      Critical Section
***  cs: array[place[i]], array[(place[i]+1) % N] := false, true;
***       Finish Section
***  fs: ...
***

fmod LOC is
  sort Loc .
  ops ss ws cs fs : -> Loc [ctor] .
endfm

fmod PID is
  sort Pid .
  ops p1 p2 p3 p4 p5 : -> Pid [ctor] .
endfm

fmod SOUP {D :: TRIV} is
  sort Soup{D} .
  subsort D$Elt < Soup{D} .
  op empty : -> Soup{D} [ctor] .
  op _ _ : Soup{D} Soup{D} -> Soup{D} [ctor assoc comm id: empty] .
endfm

fmod NAT+DEC is
  pr NAT .
  op dec : Nat -> Nat .
  var N : Nat .
  eq dec(0) = 0 .
  eq dec(s(N)) = N .
endfm

fmod OCOMP is
  pr PID .
  pr LOC .
  pr NAT+DEC .
  sort OComp .
  op pc[_]:_ : Pid Loc -> OComp [ctor] .
  op place[_]:_ : Pid Nat -> OComp [ctor] .
  op next:_ : Nat -> OComp [ctor] .
  op array[_]:_ : Nat Bool -> OComp [ctor] .
  op (abnorm:_) :  Bool -> OComp [ctor] .
endfm

view OComp from TRIV to OCOMP is
  sort Elt to OComp .
endv

fmod CONFIG is
  pr SOUP{OComp} .
  sort Config .
  op {_} : Soup{OComp} -> Config [ctor] .
***
  op isAbnorm : Soup{OComp} -> Bool .
  op inWsCs : Soup{OComp} -> Bool .
  op reset : Soup{OComp} -> Soup{OComp} .
  vars I J : Pid .
  var X : Nat .
  var B : Bool .
  var OCs : Soup{OComp} .
  eq isAbnorm((pc[I]: cs) (pc[J]: cs) OCs) = true .
  eq isAbnorm(OCs) = false [owise] .
  eq inWsCs((pc[I]: ws) OCs) = true .
  eq inWsCs((pc[I]: cs) OCs) = true .
  eq inWsCs(OCs) = false .
  eq reset((next: X) OCs) = (next: 0) reset(OCs) .
  eq reset((array[X]: B) OCs) = (if X == 0 then (array[X]: true) else (array[X]: false) fi) reset(OCs) .
  eq reset(OCs) = OCs [owise] .
***
*** Parameters
  op N : -> NzNat .
  eq N = 5 .
***
  op ainit5 : -> Config .
  eq ainit5 = {(pc[p1]: ss) (pc[p2]: ss) (pc[p3]: ss) (pc[p4]: ss) (pc[p5]: ss) 
                     (place[p1]: 0) (place[p2]: 0) (place[p3]: 0) (place[p4]: 0) (place[p5]: 0) 
                     (array[0]: true) (array[1]: true) (array[2]: true) (array[3]: true) (array[4]: true) 
                    (next: 0) (abnorm: false)} .
endfm

mod ANDERSON is
  inc CONFIG .
*** Maude variables
  vars I J K : Pid .
  vars X Y X1 M : Nat .
  vars B B1 B2 : Bool .
  vars L1 L2 L3 : Loc .
  var OCs : Soup{OComp} .
*** Rewrite rules
  crl [detect] : {(abnorm: false) OCs} => {(abnorm: true) OCs} if isAbnorm(OCs) .
  crl [reset] : {(abnorm: true) OCs} => {(abnorm: false) reset(OCs)} if not isAbnorm(OCs) /\ not inWsCs(OCs) .
  rl [start] : {(pc[I]: ss) (place[I]: X) (next: Y) (abnorm: false) OCs}
    => {(pc[I]: ws) (place[I]: Y) (next: ((Y + 1) rem N)) (abnorm: false) OCs} .
  rl [wait] : {(pc[I]: ws) (place[I]: X) (array[X]: true) (abnorm: false) OCs}
    => {(pc[I]: cs) (place[I]: X) (array[X]: true) (abnorm: false) OCs} .
  rl [abort1] : {(pc[I]: ws) (abnorm: true) OCs} => {(pc[I]: fs) (abnorm: true) OCs} .
  crl [exit] : {(pc[I]: cs) (place[I]: X) (array[X]: B1) (array[X1]: B2) (abnorm: false) OCs}
    => {(pc[I]: fs) (place[I]: X) (array[X]: false) (array[X1]: true) (abnorm: false) OCs}
  if X1 = (X + 1) rem  N .
  rl [abort2] : {(pc[I]: cs) (abnorm: true) OCs} => {(pc[I]: fs) (abnorm: true) OCs} .
endm

in model-checker .

mod ANDERSON-PREDS is
  pr ANDERSON .
  inc SATISFACTION .
  subsort Config < State .
  ops inCs1 inCs2 isAbnorm : -> Prop .
  var OCs : Soup{OComp} .
  var PROP : Prop .
  eq {(pc[p1]: cs) OCs} |= inCs1 = true .
  eq {(pc[p2]: cs) OCs} |= inCs2 = true .
  eq {(abnorm: true) OCs} |= isAbnorm = true .
  eq {OCs} |= PROP = false [owise] .
endm

mod ANDERSON-CHECK is
  inc ANDERSON-PREDS .
  inc MODEL-CHECKER .
  inc LTL-SIMPLIFIER .
endm

***(
search in ANDERSON : ainit5 =>* {OCs} such that false .
search in ANDERSON : ainit5 =>* {(array[1]: false) (array[2]: false) (pc[p1]: ss) (pc[p2]: ss) (pc[p3]: ss) OCs} .
search in ANDERSON : ainit5 =>* {(abnorm: true) OCs} .
search [1] in ANDERSON : ainit5 =>* {(abnorm: true) OCs} .
search [1] in ANDERSON : ainit5 =>* {(pc[p1]: cs) OCs} .
search [1] in ANDERSON : ainit5 =>* {(pc[p2]: cs) OCs} .
red in ANDERSON-CHECK : modelCheck(ainit5,[] (~ (inCs1 /\ inCs2))) .
red in ANDERSON-CHECK : modelCheck(ainit5,isAbnorm |-> ([] ~ (inCs1 /\ inCs2))) .
red in ANDERSON-CHECK : modelCheck(ainit5,isAbnorm |-> ([] ~ isAbnorm)) .
red in ANDERSON-CHECK : modelCheck(ainit5,isAbnorm |-> ([] isAbnorm)) .
)***
