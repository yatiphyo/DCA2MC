in metaInterpreter.maude
load queue.maude

view Job from TRIV to STATE is
    sort Elt to State .
endv

mod MANAGER is
    pr META-INTERPRETER .
    pr IQUEUE{Job} .
    pr IQUEUE{Worker} .
    pr SET{Worker} .
    pr SOLVER-MESSAGE .
    pr SOLVER-MESSAGE-CONVERTER .
    pr CHECKER-EXT .
    pr META-UTILS .

    op db-ext :_ : DatabaseExt -> Attribute .
    op original :_ : Module -> Attribute .
    op revise :_ : Module -> Attribute .
    op mn :_ : Qid -> Attribute .
    op jobs :_ : Queue{Job} -> Attribute [ctor format(! o o o)] .
    op waitingWorkers :_ : Queue{Worker} -> Attribute [ctor format(! o o o)] .
    op workers :_ : Set{Worker} -> Attribute [ctor format(! o o o)] .

    vars J : Queue{Job} .
    vars W : Queue{Worker} .
    vars SW : Set{Worker} .

    op Manager : -> Cid [ctor] .

    vars O O' MI APP CACHE : Oid .
    var  A : AttributeSet .
    var  N C : Nat .
    var B BS : Bound .
    var S : State .
    var SS : StateSet .
    var ST : StateType .
    var LL : LogList .
    var db-ext : DatabaseExt .
    var T T' : Term .
    var RT : Type .
    var M M' M'' : Module .
    vars MN : Qid .
    vars R4C : Result4Checking? .
    vars GSR : GenStatesReply .
    var GCxSR : GenCxStatesReply .
    vars TS : TermSet .
    vars L L' : Logger .

    rl [lookupBatchReply] : < O : Manager | status : initialized, A > lookupBatchReply(O, O', SS)
    => < O : Manager | status : working, jobs : enqueueFromSet(SS, emptyq), A > [print "[lookupBatchReply] States"] .

    rl [lookupBatchReply] : < O : Manager | status : working, jobs : J, A > lookupBatchReply(O, O', SS)
    => < O : Manager | status : working, jobs : enqueueFromSet(SS, J), A > [print "[lookupBatchReply] States"] .

    op enqueueFromSet : StateSet Queue{Job} -> Queue{Job} .
    eq enqueueFromSet(empty, J) = J .
    eq enqueueFromSet((S, SS), J) = enqueueFromSet(SS, J | S) .

    rl [StopWorker] : < O : Manager | workers : (MI, SW), A > stopWorking(O, O')
        => quit(MI, O) < O : Manager | workers : SW, A > stopWorking(O, O') [print "[StopWorker] " MI] .

    rl [CleanAppReq] : < O : Manager | workers : empty, app : APP, cache : CACHE, A > stopWorking(O, O')
    => < O : Manager | getLogger(A) > clearApp(APP, O) clearCache(CACHE, O) [print "[CleanAppReq]"] .

    rl [CreateWorkers] : < O : Manager |
        status : idle,
        nWorkers : N,
        A >
    => < O : Manager |
        status : initializing,
        nWorkers : N,
        workers : empty,
        waitingWorkers : emptyq,
        A >
        produceInterpreter(O, N) .

    op produceInterpreter : Oid Nat -> Configuration .
    ceq produceInterpreter(O, N) = createInterpreter(interpreterManager, O, newProcess)
        produceInterpreter(O, sd(N, 1)) if N > 0 .
    eq produceInterpreter(O, N) = none [owise] .

    rl [DbExt] : < O : Manager |
        status : initializing,
        A >
        loadedDbExt(O, O', db-ext, M, M')
    => < O : Manager |
        status : initializing,
        db-ext : db-ext,
        original : M,
        revise : M',
        mn : 'CHECKER-EXT,
        A >
        [print "[DbExt]"] .

    crl [CreatedWorker] : < O : Manager |
        status : initializing,
        db-ext : db-ext,
        original : M,
        revise : M',
        mn : MN,
        A >
        createdInterpreter(O, O', MI)
    => < O : Manager |
        status : initializing,
        db-ext : db-ext,
        original : M,
        revise : M',
        mn : MN,
        A >
        insertModule(MI, O, M'')
        if T := upTerm(upModule(originModule(getConfigExtSet(db-ext)), true))
        /\ T' := upTerm(db-ext)
        /\ M'' := addEquations(
            (eq 'originModule.Module = upTerm(M) [none] . )
            (eq 'reviseModule.Module = upTerm(M') [none] . )
            (eq 'processDbExt.DatabaseExt = upTerm(db-ext) [none] . )
            , upModule(MN, true)
        )
        [print "[CreatedWorker] " M] .

    rl [InsertedModule] : < O : Manager |
        status : initializing,
        workers : SW,
        waitingWorkers : W,
        A >
        insertedModule(O, MI)
    => < O : Manager |
        status : initializing,
        workers : (MI, SW),
        waitingWorkers : (W | MI),
        A >
        [print "[InsertedModule]"] .

    crl [CreatedWorkersDone] : < O : Manager |
        status : initializing,
        nWorkers : N,
        workers : SW,
        waitingWorkers : W,
        A >
    => < O : Manager |
        status : initialized,
        nWorkers : N,
        workers : SW,
        waitingWorkers : W,
        A >
    if qsize(W) == N
    /\ qsize(W) == | SW | [print "[CreatedWorkersDone]"] .

    crl [AssignJob] : < O : Manager |
        status : working,
        jobs : (S | J),
        waitingWorkers : (MI | W),
        mn : MN,
        original : M,
        revise : M',
        batchSize : BS,
        logger : L,
        A >
    => < O : Manager |
        status : working,
        jobs : J,
        waitingWorkers : W,
        mn : MN,
        original : M,
        revise : M',
        batchSize : BS,
        logger : L',
        A >
        handleJob(O, MI, MN, M', S, BS)
    if L' := logging(L, getDepth(S), getType(S))
    [print "[AssignJob] " L'] .

    op handleJob : Oid Oid Qid Module State Bound -> Configuration .
    eq handleJob(O, MI, MN, M, (T, ST, N, B, LL), BS) = if B == unbounded
                                                   then
                                                        reduceTerm(MI, O, MN, upTerm(checkStateReq((T, ST, N, B, LL))))
                                                   else
                                                        if ST == all
                                                        then
                                                            reduceTerm(MI, O, MN, upTerm(procGenAllStatesExt((T, ST, N, B, LL), 0, BS)))
                                                        else
                                                            reduceTerm(MI, O, MN, upTerm(procGenCxStatesExt((T, ST, N, B, LL), M, BS)))
                                                        fi
                                                   fi .

    crl [LastCheck] : < O : Manager |
        status : working,
        waitingWorkers : W,
        A >
        reducedTerm(O, MI, N, T, RT)
    => < O : Manager |
        status : working,
        waitingWorkers : (W | MI),
        A >
    if RT == 'Result4Checking [print "[LastCheck] " RT] .

    crl [LastCheck] : < O : Manager |
        status : working,
        waitingWorkers : W,
        A >
        reducedTerm(O, MI, N, T, RT)
    => < O : Manager |
        status : stopping,
        waitingWorkers : W,
        A >
        buildCx(O, O, T)
        stopWorking(O, O)
    if RT == 'Result4Checking? [print "[LastCheck] " RT] .

    crl [GenAllStates] : < O : Manager |
        cache : O',
        status : working,
        waitingWorkers : W,
        db-ext : db-ext,
        mn : MN,
        original : M,
        revise : M',
        batchSize : BS,
        A >
        reducedTerm(O, MI, N, T, RT)
    => < O : Manager |
        cache : O',
        status : working,
        waitingWorkers : W,
        db-ext : db-ext,
        mn : MN,
        original : M,
        revise : M',
        batchSize : BS,
        A >
        if | TS | > 0
        then
            reduceTerm(MI, O, MN, upTerm(procGenAllStatesExt(S, C, BS)))
            lookupBatchReq(O', O, termSetToStates(db-ext, S, TS, all))
        else
            reduceTerm(MI, O, MN, upTerm(procGenCxStatesExt(S, M', BS)))
        fi
    if RT == 'GenStatesReply
    /\ GSR := downTerm(T, errStateReply)
    /\ GSR =/= errStateReply
    /\ TS := getStates(GSR)
    /\ C := getCount(GSR)
    /\ S := getState(GSR)
    [print "[GenAllStates]"] .

    crl [GenCxStates] : < O : Manager |
        cache : O',
        status : working,
        waitingWorkers : W,
        db-ext : db-ext,
        mn : MN,
        batchSize : BS,
        A >
        reducedTerm(O, MI, N, T, RT)
    => < O : Manager |
        cache : O',
        status : working,
        waitingWorkers : W,
        db-ext : db-ext,
        mn : MN,
        batchSize : BS,
        A >
        if | TS | > 0
        then
            reduceTerm(MI, O, MN, upTerm(procGenCxStatesExt(S, M'', BS)))
            lookupBatchReq(O', O, termSetToStates(db-ext, S, TS, cx))
        else
            fetchState(O, MI)
        fi
    if RT == 'GenCxStatesReply
    /\ GCxSR := downTerm(T, errCxStateReply)
    /\ GCxSR =/= errCxStateReply
    /\ TS := getCxStates(GCxSR)
    /\ M'' := getModule(GCxSR)
    /\ S := getState(GCxSR)
    [print "[GenCxStates]"] .

    rl [FetchState] : < O : Manager |
        status : working,
        waitingWorkers : W,
        A >
        fetchState(O, MI)
    => < O : Manager |
        status : working,
        waitingWorkers : (W | MI),
        A > [print "[FetchState]"] .

    rl [MultipleCX] : < O : Manager | status : stopping, A >
        reducedTerm(O, MI, N, T, RT)
    =>  < O : Manager | status : stopping, A >
    [print "[MultipleCX] " RT] .

    crl [BuildCx] : < O : Manager |
        status : stopping,
        original : M,
        revise : M',
        A >
        buildCx(O, O, T)
    =>  < O : Manager |
        status : stopping,
        original : M,
        revise : M',
        A >
        counterexample(O, T')
    if R4C := downTerm(T, nil)
    /\ not R4C :: Result4Checking
    /\ T' := getFullCounterExample(M', R4C)
    [print "[BuildCx]"] .

    crl [CheckTermination] : < O : Manager |
        status : working,
        workers : SW,
        jobs : J,
        waitingWorkers : W,
        A >
    => < O : Manager |
        status : stopping,
        workers : SW,
        jobs : J,
        waitingWorkers : W,
        A >
        stopWorking(O, O)
    if isEmpty(J)
    /\ qsize(W) > 0
    /\ qsize(W) == | SW | [print "[CheckTermination]"] .

    rl [Bye] : < O : Manager | A > bye(O, MI) => < O : Manager | A > [print "[Bye]"] .
endm