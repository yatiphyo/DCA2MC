load buffered-socket.maude
load queue.maude

mod SERVER is
    pr BUFFERED-SOCKET .
    pr IQUEUE{Job} .
    pr IQUEUE{Worker} .
    pr SET{Worker} .
    pr SOLVER-MESSAGE .
    pr SOLVER-MESSAGE-CONVERTER .

    op jobs :_ : Queue{Job} -> Attribute [ctor format(! o o o)] .
    op waitingWorkers :_ : Queue{Worker} -> Attribute [ctor format(! o o o)] .
    op workers :_ : Set{Worker} -> Attribute [ctor format(! o o o)] .

    vars J : Queue{Job} .
    vars W : Queue{Worker} .
    vars SW : Set{Worker} .

    op Server : -> Cid [ctor] .

    vars O O' O'' LISTENER CLIENT : Oid .
    var  A : AttributeSet .
    var  N : Nat .
    vars IP DATA S : String .
    vars C : Configuration .
    var ST : State .

    crl [lookupReply] : < O : Server | jobs : J, A > lookupReply(O, O', ST)
        => < O : Server | jobs : (J | S), A >
        if S := state2string(ST) [print "[lookupReply] State"] .

    rl [StopClient] : < O : Server | workers : (CLIENT, SW), A > stopWorking(O, O')
        => CloseSocket(CLIENT, O) < O : Server | workers : SW, A > stopWorking(O, O') [print "[StopClient] " CLIENT] .

    rl [StopClient] : < O : Server | workers : empty, A > stopWorking(O, O')
        => < O : Server | workers : empty, A > [print "[StopClient]"] .

    crl [CheckTermination] :
        < O : Server | workers : SW, jobs : J, waitingWorkers : W, A >
        => < O : Server | workers : SW, jobs : J, waitingWorkers : W, A > stopWorking(O, O)
        if isEmpty(J)
        /\ qsize(W) > 0
        /\ qsize(W) == | SW | [print "[CheckTermination]"] .

    rl [MqCreatedSocket] :
        < O : Server | nWorkers : N, A > CreatedSocket(O, socketManager, LISTENER)
        => < O : Server | nWorkers : N, workers : empty, jobs : emptyq, waitingWorkers : emptyq, A >
        produceAcceptClient(LISTENER, O, N) [print "[MqCreatedSocket]"] .

    op produceAcceptClient : Oid Oid Nat -> Configuration .
    eq produceAcceptClient(LISTENER, O, N) = if N > 0
                                            then AcceptClient(LISTENER, O) produceAcceptClient(LISTENER, O, sd(N, 1))
                                            else none
                                            fi .

    rl [MqAcceptedClient] :
        < O : Server | workers : SW, A > AcceptedClient(O, LISTENER, IP, CLIENT)
        => < O : Server | workers : (CLIENT, SW), A > Receive(CLIENT, O) [print "[MqAcceptedClient]"] .

    crl [MqReceived] :
        < O : Server | jobs : J, waitingWorkers : W, A > Received(O, CLIENT, DATA)
        => < O : Server | jobs : J, waitingWorkers : (W | CLIENT), A >
        if DATA == getJob [print "[MqReceived] " DATA] .

    crl [MqReceived] :
        < O : Server | A > Received(O, CLIENT, DATA)
        => < O : Server | A > stopWorking(O, CLIENT)
        if DATA == stop [print "[MqReceived] " DATA] .

    rl [SendJob] : < O : Server | jobs : (S | J), waitingWorkers : (CLIENT | W), A >
        => < O : Server | jobs : J, waitingWorkers : W, A >
        Send(CLIENT, O, S) [print "[SendJob]"] .

    crl [MqReceived] :
        < O : Server | cache : O', A > Received(O, CLIENT, DATA)
        => < O : Server | cache : O', A > lookupReq(O', O, ST)
        if DATA =/= getJob
        /\ DATA =/= stop
        /\ ST := string2state(DATA) [print "[MqReceived] State "] .

    rl [MqSent] :
        < O : Server | A > Sent(O, CLIENT)
        => < O : Server | A > [print "[MqSent]"] .

    rl [MqClosedSocket] :
        < O : Server | A > ClosedSocket(O, CLIENT, DATA)
        => < O : Server | A > [print "[MqClosedSocket]"] .
endm