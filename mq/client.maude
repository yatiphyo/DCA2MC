load buffered-socket.maude

mod CLIENT is
    pr BUFFERED-SOCKET .
    pr SOLVER-MESSAGE .
    pr SOLVER-MESSAGE-CONVERTER .

    op Client : -> Cid .

    vars O O' O'' CLIENT : Oid .
    var  A : AttributeSet .
    vars DATA S : String .
    vars SERROR : [String] .
    vars ST : State .
    vars SS : StateSet .

    --- crl [LookupReply] : < O : Client | socket : CLIENT, A > lookupReply(O, O', ST)
    --- => < O : Client | socket : CLIENT, A > Send(CLIENT, O, S)
    --- if S := state2string(ST) [print "[LookupReply] " S] .

    --- crl [LookupReply] : < O : Client | app : O'', A > lookupReply(O, O', ST)
    --- => < O : Client | app : O'', A >
    --- error(O'', O, noParse, "Cannot convert state to string")
    --- if SERROR := state2string(ST) [print "[LookupReply] Cannot convert state to string" SERROR] .

    rl [LookupBatchReply] : < O : Client | socket : CLIENT, app : O', A > lookupBatchReply(O, O'', SS)
    => < O : Client | socket : CLIENT, app : O', A >
    resumeReq(O', O) produceMessages(CLIENT, O, SS) [print "[LookupBatchReply] " SS] .

    op produceMessages : Oid Oid StateSet -> Configuration .
    eq produceMessages(CLIENT, O, empty) = none .
    eq produceMessages(CLIENT, O, (ST, SS)) = Send(CLIENT, O, state2string(ST)) produceMessages(CLIENT, O, SS) [print "[Send] " ST] .

    rl [FetchState] : < O : Client | socket : CLIENT, A > fetchState(O, O')
        => < O : Client | socket : CLIENT, A >
        Send(CLIENT, O, getJob) [print "[FetchState]"] .

    rl [StopWorking] : < O : Client | socket : CLIENT, A > stopWorking(O, O')
        => < O : Client | socket : CLIENT, A > Send(CLIENT, O, stop) [print "[StopWorking]"] .

    rl [MqCreatedSocket] :
        < O : Client | A > CreatedSocket(O, socketManager, CLIENT)
        => < O : Client | socket : CLIENT, A >
        Send(CLIENT, O, getJob)
        Receive(CLIENT, O) [print "[MqCreatedSocket]"] .

    rl [MqSent] :
        < O : Client | A > Sent(O, CLIENT)
        => < O : Client | A > [print "[MqSent]"] .

    crl [MqReceived] :
        < O : Client | A > Received(O, CLIENT, DATA)
        => < O : Client | A >
        if DATA == waiting [print "[MqReceived] Received -> " DATA] .

    crl [MqReceived] :
        < O : Client | app : O', A > Received(O, CLIENT, DATA)
        => if (string2state(DATA) == null)
            then < O : Client | app : O',  A > error(O', O, noParse, DATA)
            else < O : Client | app : O', A > handle(O', O, string2state(DATA))
            fi
        if not equalsTo(DATA, waiting)
        /\ not equalsTo(DATA, done) [print "[MqReceived] Received -> " DATA] .

    rl [MqClosedSocket] :
        < O : Client | A > ClosedSocket(O, CLIENT, S)
        => < O : Client | A > [print "[MqClosedSocket]"] .
endm
