fmod IQUEUE{X :: TRIV} is
    protecting BOOL .
    pr NAT .

    sort NeQueue{X} Queue{X} .
    subsort NeQueue{X} < Queue{X} .
    op empty : -> Queue{X} [ctor] .
    op enqueue : Queue{X} X$Elt -> NeQueue{X} [ctor] .
    op dequeue : NeQueue{X} -> Queue{X} .
    op first : NeQueue{X} -> X$Elt .
    op isEmpty : Queue{X} -> Bool .
    op qsize : Queue{X} -> Nat .
    var Q : Queue{X} .
    var E : X$Elt .

    eq qsize(empty) = 0 .
    eq qsize(enqueue(Q, E)) = qsize(Q) + 1 .

    eq dequeue(enqueue(empty, E)) = empty .
    ceq dequeue(enqueue(Q, E)) = enqueue(dequeue(Q), E) if Q =/= empty .
    eq first(enqueue(empty, E)) = E .
    ceq first(enqueue(Q, E)) = first(Q) if Q =/= empty .
    eq isEmpty(empty) = true .
    eq isEmpty(enqueue(Q, E)) = false .
endfm

fmod MQ-MESSAGE{X :: TRIV} is
    sorts MqMsg{X} MqMsgInfo{X} MqMsgState{X} .
    subsort MqMsgInfo{X} < MqMsg{X} .
    ops idle consuming finished : -> MqMsgState{X} [ctor] .
    op status :_ : MqMsgState{X} -> MqMsgInfo{X} [ctor] .
    op msg :_ : X$Elt -> MqMsgInfo{X} [ctor] .
    op empty : -> MqMsg{X} [ctor] .
    op __ : MqMsg{X} MqMsg{X} -> MqMsg{X} [ctor assoc comm id: empty] .

    op buildJob : MqMsgState{X} X$Elt -> MqMsg{X} .
    eq buildJob(S:MqMsgState{X}, E:X$Elt) = (status : S:MqMsgState{X}) (msg : E:X$Elt) .

    vars M : MqMsg{X} .
    op getContent : MqMsg{X} -> X$Elt .
    eq getContent((msg : E:X$Elt) M) = E:X$Elt .
endfm

fmod JOB-MESSAGE is
    pr MQ-MESSAGE{Nat} .
endfm

view Job1 from TRIV to JOB-MESSAGE is
    sort Elt to MqMsg{Nat} .
endv

view Job from TRIV to STRING is
    sort Elt to String .
endv

view Worker from TRIV to CONFIGURATION is
    sort Elt to Oid .
endv

--- red enqueue(empty, (status : idle msg : 2)) .
--- fmod TEST-MQ-MESSAGE is
---     pr MQ-MESSAGE{Nat} .

---     op msg : -> MqMsg{Nat} .
---     eq msg = buildJob(idle, 1) .
--- endfm

--- red in TEST-MQ-MESSAGE : msg .
--- red in TEST-MQ-MESSAGE : getContent(msg) .