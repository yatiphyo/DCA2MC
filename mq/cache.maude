mod CACHE-INTERFACE is
    pr SOLVER-MESSAGE .
    pr MAP{Nat,TermSet} .

    op Cache : -> Cid [ctor] .

    op CxState :_ : Map{Nat,TermSet} -> Attribute [ctor format(! o o o)] .
    op AllState :_ : Map{Nat,TermSet} -> Attribute [ctor format(! o o o)] .
endm

view Map`{Nat`,TermSet`} from TRIV to CACHE-INTERFACE is
    sort Elt to Map{Nat,TermSet} .
endv

mod CACHE is
    pr TERMSET-EXT .
    pr CACHE-INTERFACE .
    pr 3TUPLE{Map{Nat,TermSet},Map{Nat,TermSet},StateSet} * (
                 op p1_ to getCacheCxState,
                 op p2_ to getCacheAllState,
                 op p3_ to getStates,
                 sort Tuple{Map{Nat,TermSet},Map{Nat,TermSet},StateSet} to CacheResult) .

    vars O O' O'' : Oid .
    vars MCX MCX' MAS MAS' M : Map{Nat,TermSet} .
    vars Atts : AttributeSet .
    vars N D : Nat .
    vars T T' : Term .
    vars AS CX TS : TermSet .
    vars S : State .
    vars SS SS' : StateSet .
    vars CR : CacheResult .
    vars L L' : Logger .
    vars J : Queue{State} .

    --- filter states for conditional stable model checking
    crl [filterStatesReq] : < O : Cache | AllState : MAS, CxState : MCX, server : O', logger : L, Atts >
        filterStatesReq(O, O'', S | J)
    => < O : Cache | AllState : MAS', CxState : MCX, server : O', logger : L', Atts >
        filterStatesReply(O', O,
            if MCX[D] == undefined then (S | J) else filterStates(MCX[D], S | J) fi
        )
    if D := getDepth(S)
    /\ MAS' := updateAllState(MAS, MCX, D)
    /\ L' := updateLogger(L, D, (getNumStates(MAS', D), getNumStates(MCX, D)))
    /\ B:Bool := L == L'
    [print "[filterStatesReq] L == L' = " B:Bool]
    .

    op updateAllState : Map{Nat,TermSet} Map{Nat,TermSet} Nat -> Map{Nat,TermSet} .
    eq updateAllState(MAS, MCX, D) = if MAS[D] == undefined or-else MCX[D] == undefined
                                     then MAS
                                     else insert(D, (MAS[D] except MCX[D]), MAS)
                                     fi .
    op getNumStates : Map{Nat,TermSet} Nat -> Nat .
    eq getNumStates(M, D) = if M[D] == undefined then 0 else | M[D] | fi .

    op filterStates : TermSet Queue{State} -> Queue{State} .
    eq filterStates(CX, emptyq) = emptyq .
    eq filterStates(CX, S | J) = if getType(S) == cx
                                 then
                                    S | filterStates(CX, J)
                                 else
                                    if getState(S) in CX
                                    then filterStates(CX, J)
                                    else S | filterStates(CX, J)
                                    fi
                                 fi .
    --- lookup request for master
    crl [lookupReq] : < O : Cache | CxState : MCX, AllState : MAS, server : O', logger : L, Atts  > lookupReq(O, O'', S)
    => if getType(S) == cx
    then (
        if MCX[getDepth(S)] == undefined
        then < O : Cache |
            CxState : insert(getDepth(S), getState(S), MCX),
            AllState : MAS, server : O', logger : L', Atts > lookupReply(O', O, S)
        else (
            if getState(S) in MCX[getDepth(S)]
            then < O : Cache | CxState : MCX, AllState : MAS, server : O', logger : L, Atts > lookupReplyEmpty(O', O)
            else < O : Cache |
                CxState : insert(getDepth(S), getState(S) | MCX[getDepth(S)], MCX),
                AllState : MAS, server : O', logger : L', Atts > lookupReply(O', O, S)
            fi
        )
        fi
    )
    else (
        if MAS[getDepth(S)] == undefined
        then < O : Cache |
            AllState : insert(getDepth(S), getState(S), MAS),
            CxState : MCX, server : O', logger : L', Atts > lookupReply(O', O, S)
        else (
            if getState(S) in MAS[getDepth(S)]
            then < O : Cache | CxState : MCX, AllState : MAS, server : O', logger : L, Atts > lookupReplyEmpty(O', O)
            else
            < O : Cache |
                AllState : insert(getDepth(S), getState(S) | MAS[getDepth(S)], MAS),
                CxState : MCX, server : O', logger : L', Atts > lookupReply(O', O, S)
            fi
        )
        fi
    )
    fi
    if S =/= null
    /\ L' := logging(L, getDepth(S), getType(S))
    [print "[lookupReq] State"] .

    crl [lookupReq] : < O : Cache | CxState : MCX, AllState : MAS, server : O', Atts > lookupReq(O, O'', S)
    => < O : Cache | CxState : MCX, AllState : MAS, server : O', Atts > if S == null [print "[lookupReq] Null"] .

    --- lookup request for workers
    op lookupStates : Map{Nat,TermSet} Map{Nat,TermSet} StateSet -> CacheResult .
    eq lookupStates(MCX, MAS, SS) = $lookupStates(MCX, MAS, SS, empty) .

    op $lookupStates : Map{Nat,TermSet} Map{Nat,TermSet} StateSet StateSet -> CacheResult .
    eq $lookupStates(MCX, MAS, empty, SS') =  (MCX, MAS, SS') .
    eq $lookupStates(MCX, MAS, (S, SS), SS') =  if getType(S) == cx
    then (
        if MCX[getDepth(S)] == undefined
        then
            $lookupStates(insert(getDepth(S), getState(S), MCX), MAS, SS, insert(S, SS'))
        else (
            if getState(S) in MCX[getDepth(S)]
            then $lookupStates(MCX, MAS, SS, SS')
            else $lookupStates(insert(getDepth(S), getState(S) | MCX[getDepth(S)], MCX), MAS, SS, insert(S, SS'))
            fi
        )
        fi
    )
    else (
        if MAS[getDepth(S)] == undefined
        then $lookupStates(MCX, insert(getDepth(S), getState(S), MAS), SS, insert(S, SS'))
        else (
            if getState(S) in MAS[getDepth(S)]
            then $lookupStates(MCX, MAS, SS, SS')
            else $lookupStates(MCX, insert(getDepth(S), getState(S) | MAS[getDepth(S)], MAS), SS, insert(S, SS'))
            fi
        )
        fi
    )
    fi .

    crl [lookupBatchReq] : < O : Cache | CxState : MCX, AllState : MAS, server : O', app : O'', Atts > lookupBatchReq(O, O'', SS)
    => if SS' == empty
        then < O : Cache | CxState : MCX', AllState : MAS', server : O', app : O'', Atts > resumeReq(O'', O)
        else < O : Cache | CxState : MCX', AllState : MAS', server : O', app : O'', Atts > lookupBatchReply(O', O, SS')
        fi
    if CR := lookupStates(MCX, MAS, SS)
    /\ SS' := getStates(CR)
    /\ MCX' := getCacheCxState(CR)
    /\ MAS' := getCacheAllState(CR) [print "[lookupBatchReq] States "] .

    rl [clearCache] : < O : Cache | Atts > clearCache(O, O')
    =>  < O : Cache | getLogger(Atts) > .

    op getLogger : AttributeSet -> AttributeSet .
    eq getLogger(logger : L, Atts) = logger : L .
    eq getLogger(Atts) = none [owise] .
endm
