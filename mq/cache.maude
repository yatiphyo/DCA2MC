mod CACHE-INTERFACE is
    pr SOLVER-MESSAGE .
    pr MAP{Nat,TermSet} .

    op Cache : -> Cid [ctor] .

    op CxState :_ : Map{Nat,TermSet} -> Attribute [ctor format(! o o o)] .
    op AllState :_ : Map{Nat,TermSet} -> Attribute [ctor format(! o o o)] .
endm

view Map`{Nat`,TermSet`} from TRIV to CACHE-INTERFACE is
    sort Elt to Map{Nat,TermSet} .
endv

mod CACHE is
    pr CACHE-INTERFACE .
    pr 3TUPLE{Map{Nat,TermSet},Map{Nat,TermSet},StateSet} * (
                 op p1_ to getCacheCxState,
                 op p2_ to getCacheAllState,
                 op p3_ to getStates,
                 sort Tuple{Map{Nat,TermSet},Map{Nat,TermSet},StateSet} to CacheResult) .

    vars O O' O'' : Oid .
    vars MCX MCX' MAS MAS' : Map{Nat,TermSet} .
    vars Atts : AttributeSet .
    vars N : Nat .
    vars T T' : Term .
    vars AS CX TS : TermSet .
    vars S : State .
    vars SS SS' : StateSet .
    vars CR : CacheResult .
    vars L L' : Logger .

    --- lookup request for master
    crl [lookupReq] : < O : Cache | CxState : MCX, AllState : MAS, server : O', logger : L, Atts  > lookupReq(O, O'', S)
    => if getType(S) == cx
    then (
        if MCX[getDepth(S)] == undefined
        then < O : Cache |
            CxState : insert(getDepth(S), getState(S), MCX),
            AllState : MAS, server : O', logger : L', Atts > lookupReply(O', O, S)
        else (
            if getState(S) in MCX[getDepth(S)]
            then < O : Cache | CxState : MCX, AllState : MAS, server : O', logger : L, Atts > lookupReplyEmpty(O', O)
            else < O : Cache |
                CxState : insert(getDepth(S), getState(S) | MCX[getDepth(S)], MCX),
                AllState : MAS, server : O', logger : L', Atts > lookupReply(O', O, S)
            fi
        )
        fi
    )
    else (
        if MAS[getDepth(S)] == undefined
        then < O : Cache |
            AllState : insert(getDepth(S), getState(S), MAS),
            CxState : MCX, server : O', logger : L', Atts > lookupReply(O', O, S)
        else (
            if getState(S) in MAS[getDepth(S)]
            then < O : Cache | CxState : MCX, AllState : MAS, server : O', logger : L, Atts > lookupReplyEmpty(O', O)
            else
            < O : Cache |
                AllState : insert(getDepth(S), getState(S) | MAS[getDepth(S)], MAS),
                CxState : MCX, server : O', logger : L', Atts > lookupReply(O', O, S)
            fi
        )
        fi
    )
    fi
    if S =/= null
    /\ L' := logging(L, getDepth(S), getType(S))
    [print "[lookupReq] State"] .

    crl [lookupReq] : < O : Cache | CxState : MCX, AllState : MAS, server : O', Atts > lookupReq(O, O'', S)
    => < O : Cache | CxState : MCX, AllState : MAS, server : O', Atts > if S == null [print "[lookupReq] Null"] .

    --- lookup request for workers
    op lookupStates : Map{Nat,TermSet} Map{Nat,TermSet} StateSet -> CacheResult .
    eq lookupStates(MCX, MAS, SS) = $lookupStates(MCX, MAS, SS, empty) .

    op $lookupStates : Map{Nat,TermSet} Map{Nat,TermSet} StateSet StateSet -> CacheResult .
    eq $lookupStates(MCX, MAS, empty, SS') =  (MCX, MAS, SS') .
    eq $lookupStates(MCX, MAS, (S, SS), SS') =  if getType(S) == cx
    then (
        if MCX[getDepth(S)] == undefined
        then
            $lookupStates(insert(getDepth(S), getState(S), MCX), MAS, SS, insert(S, SS'))
        else (
            if getState(S) in MCX[getDepth(S)]
            then $lookupStates(MCX, MAS, SS, SS')
            else $lookupStates(insert(getDepth(S), getState(S) | MCX[getDepth(S)], MCX), MAS, SS, insert(S, SS'))
            fi
        )
        fi
    )
    else (
        if MAS[getDepth(S)] == undefined
        then $lookupStates(MCX, insert(getDepth(S), getState(S), MAS), SS, insert(S, SS'))
        else (
            if getState(S) in MAS[getDepth(S)]
            then $lookupStates(MCX, MAS, SS, SS')
            else $lookupStates(MCX, insert(getDepth(S), getState(S) | MAS[getDepth(S)], MAS), SS, insert(S, SS'))
            fi
        )
        fi
    )
    fi .

    crl [lookupBatchReq] : < O : Cache | CxState : MCX, AllState : MAS, server : O', app : O'', Atts > lookupBatchReq(O, O'', SS)
    => if SS' == empty
        then < O : Cache | CxState : MCX', AllState : MAS', server : O', app : O'', Atts > resumeReq(O'', O)
        else < O : Cache | CxState : MCX', AllState : MAS', server : O', app : O'', Atts > lookupBatchReply(O', O, SS')
        fi
    if CR := lookupStates(MCX, MAS, SS)
    /\ SS' := getStates(CR)
    /\ MCX' := getCacheCxState(CR)
    /\ MAS' := getCacheAllState(CR) [print "[lookupBatchReq] States "] .

    rl [clearCache] : < O : Cache | Atts > clearCache(O, O')
    =>  < O : Cache | getLogger(Atts) > .

    op getLogger : AttributeSet -> AttributeSet .
    eq getLogger(logger : L, Atts) = logger : L .
    eq getLogger(Atts) = none [owise] .
endm
